<html>
<head></head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script lang="js">
        
async function run() {
    const trainingUrl = '/data/wdbc-train.csv';
    
    // Load training data with diagnosis as label (column 1)
    const trainingData = tf.data.csv(trainingUrl, {
        columnConfigs: {
            diagnosis: {
                isLabel: true
            }
        }
    });
    
    // Convert training data into batched tensors
    const convertedTrainingData = trainingData
        .map(({xs, ys}) => {
            return {
                xs: Object.values(xs),
                ys: ys
            };
        })
        .batch(32);
    
    const testingUrl = '/data/wdbc-test.csv';
    
    // Load testing data with diagnosis as label (column 1)
    const testingData = tf.data.csv(testingUrl, {
        columnConfigs: {
            diagnosis: {
                isLabel: true
            }
        }
    });
    
    // Convert testing data into batched tensors
    const convertedTestingData = testingData
        .map(({xs, ys}) => {
            return {
                xs: Object.values(xs),
                ys: ys
            };
        })
        .batch(32);
    
    // Number of features (30 measurements excluding ID and diagnosis)
    const numOfFeatures = 30;
    
    // Create sequential model
    const model = tf.sequential();
    
    // Input layer
    model.add(tf.layers.dense({
        inputShape: [numOfFeatures],
        units: 64,
        activation: 'relu'
    }));
    
    // Hidden layer 1
    model.add(tf.layers.dense({
        units: 32,
        activation: 'relu'
    }));
    
    // Hidden layer 2
    model.add(tf.layers.dense({
        units: 16,
        activation: 'relu'
    }));
    
    // Output layer (single unit with sigmoid for binary classification)
    model.add(tf.layers.dense({
        units: 1,
        activation: 'sigmoid'
    }));
    
    // Compile model
    model.compile({
        loss: 'binaryCrossentropy',
        optimizer: 'rmsprop',
        metrics: ['accuracy']
    });
    
    // Train model
    await model.fitDataset(convertedTrainingData, 
        {
            epochs: 100,
            validationData: convertedTestingData,
            callbacks: {
                onEpochEnd: async(epoch, logs) => {
                    console.log("Epoch: " + epoch + " Loss: " + logs.loss + " Accuracy: " + logs.acc);
                }
            }
        });
    
    await model.save('downloads://my_model');
}

run();
    </script>
<body>
</body>
</html>
